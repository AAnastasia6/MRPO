from dataclasses import dataclass
import json
import os

# Класс Клиент (имя, адрес, номер телефона)
@dataclass
class Client:
    full_name: str
    address: str
    phone: str


# Класс Филиал (адрес)
@dataclass(frozen=True)
class Branch:
    address: str

# Класс Товар (наименование, цена, количество в наличии)
@dataclass
class Product:
    name: str
    price: int
    count: int

# Класс Покупка (дата покупки, количество купленного товара, id клиента-покупателя, id филиала-места выдачи)
@dataclass(frozen=True)
class Purchase:
    date: str
    quantity: int
    client_id: int
    product_id: int
    branch_id: int


# Класс Поставщик (наименование)
@dataclass(frozen=True)
class Provider:
    name: str


file_path = 'data.json'

if not os.path.exists(file_path):
    # Create the initial JSON structure
    data = {
        'administrators': [],
        'masters': [],
        'branchs': [],
        'services': [],
        'promotions': [],
        'clients': [],
        'reviews': [],
        'sessions': [],
        'purchases': [],
        'providers': [],
        'products': []
    }

    with open(file_path, 'w') as f:
        json.dump(data, f, indent=4)
    print("File 'data.json' successfully created.")
else:
    print("File 'data.json' already exists.")

class PurchaseServise:
    @staticmethod
    def check_purchase(purchase, product, product_count_available, branch):

        if product is None:
            print('Выбранный товар не существует')
            return False

        if branch is None:
            print('Выбранный филиал недоступен')
            return False

        if purchase.quantity > int(product_count_available):
            print("Товара недостаточно на складе")
            return False

        return True


class SupplyServise:
    @staticmethod
    def check_supply(product, provider):
        if product is None:
            print('Выбранный товар не существует')
            return False

        if provider is None:
            print('Выбранный поставщик не существует')
            return False
        return True


class ServiceLayer:
    @staticmethod
    def add_object(objectt):
        if isinstance(objectt, Client):
            id=repository.get_id_new('client')
            repository.add_entity(objectt, 'client', id)
            return True


        if isinstance(objectt, Branch):
            id=repository.get_id_new('branch')
            repository.add_entity(objectt, 'branch', id)

        if isinstance(objectt, Product):
            id=repository.get_id_new('product')
            repository.add_entity(objectt, 'product', id)
            return True

        if isinstance(objectt, Provider):
            id=repository.get_id_new('provider')
            repository.add_entity(objectt, 'provider', id)

        if isinstance(objectt, Purchase):
            id=repository.get_id_new('purchase')
            product = repository.get_entity_by_id('product', objectt.product_id)
            product_count_available = repository.get_product_count(objectt.product_id)
            branch = repository.get_entity_by_id('branch', objectt.branch_id)
            if PurchaseServise.check_purchase(objectt, product, product_count_available, branch):
                repository.add_entity(objectt, 'purchase', id)
                repository.update_product_count(objectt.product_id, objectt.quantity, '-')
                return True
            else:
                return False


    @staticmethod
    def remove_object(object_name, id):
        if (repository.remove_entity(object_name, id)):
            return True
        else:
            return False

    @staticmethod
    def get_all_object(object_name):
        return repository.get_all_entities(object_name)

    @staticmethod
    def get_all_purchase_by_client(client_id):
        return repository.get_all_purchase_by_client_id(client_id)


    @staticmethod
    def order_a_product(product_id, provider_id, count):
        product = repository.get_entity_by_id('product', product_id)
        provider = repository.get_entity_by_id('provider', provider_id)
        if SupplyServise.check_supply(product, provider):
            repository.update_product_count(product_id, count, '+')
            return True
        else:
            return False

    @staticmethod
    def remove_purchase(purchase_id):
        purchase = repository.get_entity_by_id("purchase", purchase_id)
        if purchase:
            repository.update_product_count(int(purchase['product_id']), int(purchase['quantity']), "+")
            repository.remove_entity("purchase", purchase_id)
            return True
        else:
            return False


class JSONRepository:
    def __init__(self, file_path):
        self.file_path = file_path
        with open(file_path, 'r') as f:
            self.data = json.load(f)

    def get_id_new(self, entity_name):
        entity_list = self.data.get(entity_name + "s", [])
        max_id = 0
        for entity in entity_list:
            entity_id = int(entity.get('id', 0))
            max_id = max(max_id, entity_id)

        print(f"Максимальный id для элементов: {max_id}")
        return max_id + 1

    def add_entity(self, entity, entity_type, id):
        entity_list = self.data.get(entity_type + "s", [])
        entity_list.append({"id": str(id)})
        for prop, value in vars(entity).items():
            if not prop.startswith("_"):
                entity_list[-1][prop] = str(value)
        self.save_data()
        print(f"{entity_type.capitalize()} успешно добавлен.")



    def remove_entity(self, entity_type, id):
        entity_list = self.data.get(entity_type + "s", [])
        for i, entity in enumerate(entity_list):
            if entity.get("id") == str(id):
                del entity_list[i]
                self.save_data()
                print(f"{entity_type.capitalize()} с id {id} успешно удален.")
                return True

        print(f"{entity_type.capitalize()} с id {id} не найден.")
        return False

    def get_entity_by_id(self, entity_name, id):
        entity_list = self.data.get(entity_name + "s", [])
        for entity in entity_list:
            if entity.get('id') == str(id):
                return entity
        return None

    def get_all_entities(self, entity_type):
        return self.data.get(entity_type + "s", [])

    def update_product_count(self, product_id, count_diff, operation):
        products = self.data.get("products", [])
        for i, product in enumerate(products):
            if product.get('id') == str(product_id):
                if operation == '+':
                    products[i]["count"] = int(products[i]["count"]) + count_diff
                elif operation == '-':
                    products[i]["count"] = int(products[i]["count"]) - count_diff
                self.save_data()
                print(f"Данные успешно обновлены")
                return

        print(f"Продукт с id {product_id} не найден.")

    def get_all_purchase_by_client_id(self, id):
        purchases = self.data.get("purchases", [])
        result = []
        for purchase in purchases:
            if purchase.get("client_id") == str(id):
                result.append(purchase)
        return result

    def get_product_count(self, product_id):
        products = self.data.get("products", [])
        for product in products:
            if product.get('id') == str(product_id):
                return product.get('count')
        return None


    def save_data(self):
        with open(self.file_path, 'w') as f:
            json.dump(self.data, f, indent=4)



repository = JSONRepository('data.json')



# client = Client(full_name="Ivanov Ivan", address="Mira, 28", phone="123-456-789")
# ServiceLayer.add_object(client)

# product = Product(name="Gel for hair", price=200, count=0)
# ServiceLayer.add_object(product)

# provider = Provider(name="OOO Petrov ")
# ServiceLayer.add_object(provider)

# ServiceLayer.order_a_product(1, 1, 20)

# purchase = Purchase(date="12-07-2024", quantity=5, client_id=1, product_id=1, branch_id=1)
# ServiceLayer.add_object(purchase)
# print(ServiceLayer.get_all_object("product"))
#
# print(ServiceLayer.get_all_purchase_by_client(1))
